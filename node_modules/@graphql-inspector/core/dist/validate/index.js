"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var dependency_graph_1 = require("dependency-graph");
var document_1 = require("../ast/document");
var graphql_2 = require("../utils/graphql");
var query_depth_1 = require("./query-depth");
var apollo_1 = require("../utils/apollo");
function validate(schema, sources, options) {
    var config = __assign({ strictDeprecated: true, strictFragments: true, apollo: false }, options);
    var invalidDocuments = [];
    // read documents
    var documents = sources.map(document_1.readDocument);
    // keep all named fragments
    var fragments = [];
    var fragmentNames = [];
    var graph = new dependency_graph_1.DepGraph({ circular: true });
    documents.forEach(function (doc) {
        doc.fragments.forEach(function (fragment) {
            fragmentNames.push(fragment.node.name.value);
            fragments.push(fragment);
            graph.addNode(fragment.node.name.value, fragment.node);
        });
    });
    fragments.forEach(function (fragment) {
        var depends = extractFragments(graphql_1.print(fragment.node));
        if (depends) {
            depends.forEach(function (name) {
                graph.addDependency(fragment.node.name.value, name);
            });
        }
    });
    documents
        // since we include fragments, validate only operations
        .filter(function (doc) { return doc.hasOperations; })
        .forEach(function (doc) {
        var docWithOperations = {
            kind: 'Document',
            definitions: doc.operations.map(function (d) { return d.node; }),
        };
        var extractedFragments = (extractFragments(graphql_1.print(docWithOperations)) || [])
            // resolve all nested fragments
            .map(function (fragmentName) {
            return resolveFragment(graph.getNodeData(fragmentName), graph);
        })
            // flatten arrays
            .reduce(function (list, current) { return list.concat(current); }, [])
            // remove duplicates
            .filter(function (def, i, all) {
            return all.findIndex(function (item) { return item.name.value === def.name.value; }) === i;
        });
        var merged = {
            kind: 'Document',
            definitions: __spreadArrays(docWithOperations.definitions, extractedFragments),
        };
        var transformedSchema = config.apollo
            ? apollo_1.transformSchemaWithApollo(schema)
            : schema;
        var transformedDoc = config.apollo
            ? apollo_1.transformDocumentWithApollo(merged)
            : merged;
        var errors = graphql_1.validate(transformedSchema, transformedDoc) || [];
        if (config.maxDepth) {
            var depthError = query_depth_1.validateQueryDepth({
                source: doc.source,
                doc: transformedDoc,
                maxDepth: config.maxDepth,
                fragmentGraph: graph,
            });
            if (depthError) {
                errors.push(depthError);
            }
        }
        var deprecated = config.strictDeprecated
            ? graphql_2.findDeprecatedUsages(transformedSchema, graphql_1.parse(doc.source.body))
            : [];
        var duplicatedFragments = config.strictFragments
            ? findDuplicatedFragments(fragmentNames)
            : [];
        if (sumLengths(errors, duplicatedFragments, deprecated) > 0) {
            invalidDocuments.push({
                source: doc.source,
                errors: __spreadArrays(errors, duplicatedFragments),
                deprecated: deprecated,
            });
        }
    });
    return invalidDocuments;
}
exports.validate = validate;
function findDuplicatedFragments(fragmentNames) {
    return fragmentNames
        .filter(function (name, i, all) { return all.indexOf(name) !== i; })
        .map(function (name) { return new graphql_1.GraphQLError("Name of '" + name + "' fragment is not unique"); });
}
//
// PostInfo -> AuthorInfo
// AuthorInfo -> None
//
function resolveFragment(fragment, graph) {
    return graph
        .dependenciesOf(fragment.name.value)
        .reduce(function (list, current) { return __spreadArrays(list, resolveFragment(graph.getNodeData(current), graph)); }, [fragment]);
}
function extractFragments(document) {
    return (document.match(/[\.]{3}[a-z0-9\_]+\b/gi) || []).map(function (name) {
        return name.replace('...', '');
    });
}
function sumLengths() {
    var arrays = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arrays[_i] = arguments[_i];
    }
    return arrays.reduce(function (sum, _a) {
        var length = _a.length;
        return sum + length;
    }, 0);
}
//# sourceMappingURL=index.js.map