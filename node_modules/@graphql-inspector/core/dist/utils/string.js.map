{"version":3,"file":"string.js","sourceRoot":"","sources":["../../src/utils/string.ts"],"names":[],"mappings":"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","sourcesContent":["export interface Target {\n  typeId: string;\n  value: string;\n}\n\nexport interface Rating {\n  target: Target;\n  rating: number;\n}\n\nexport interface BestMatch {\n  ratings: Rating[];\n  bestMatch: Rating;\n}\n\nfunction compareTwoStrings(str1: string, str2: string) {\n  if (!str1.length && !str2.length) return 1;\n  if (!str1.length || !str2.length) return 0;\n  if (str1.toUpperCase() === str2.toUpperCase()) return 1;\n  if (str1.length === 1 && str2.length === 1) return 0;\n\n  const pairs1 = wordLetterPairs(str1);\n  const pairs2 = wordLetterPairs(str2);\n  const union = pairs1.length + pairs2.length;\n  let intersection = 0;\n  pairs1.forEach(pair1 => {\n    for (let i = 0, pair2; (pair2 = pairs2[i]); i++) {\n      if (pair1 !== pair2) continue;\n      intersection++;\n      pairs2.splice(i, 1);\n      break;\n    }\n  });\n  return (intersection * 2) / union;\n}\n\nexport function findBestMatch(\n  mainString: string,\n  targetStrings: Target[],\n): BestMatch {\n  if (!areArgsValid(mainString, targetStrings))\n    throw new Error(\n      'Bad arguments: First argument should be a string, second should be an array of strings',\n    );\n  const ratings = targetStrings.map(target => ({\n    target,\n    rating: compareTwoStrings(mainString, target.value),\n  }));\n  const bestMatch = Array.from(ratings).sort((a, b) => b.rating - a.rating)[0];\n  return {ratings, bestMatch};\n}\n\nfunction flattenDeep(arr: any): string[] {\n  return Array.isArray(arr)\n    ? arr.reduce((a, b) => a.concat(flattenDeep(b)), [])\n    : [arr];\n}\n\nfunction areArgsValid(mainString: string, targetStrings: Target[]) {\n  if (typeof mainString !== 'string') return false;\n  if (!Array.isArray(targetStrings)) return false;\n  if (!targetStrings.length) return false;\n  if (targetStrings.find(s => typeof s.value !== 'string')) return false;\n  return true;\n}\n\nfunction letterPairs(str: string) {\n  const pairs = [];\n  for (let i = 0, max = str.length - 1; i < max; i++)\n    pairs[i] = str.substring(i, i + 2);\n  return pairs;\n}\n\nfunction wordLetterPairs(str: string) {\n  const pairs = str\n    .toUpperCase()\n    .split(' ')\n    .map(letterPairs);\n  return flattenDeep(pairs);\n}\n"]}