"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
function safeChangeForField(oldType, newType) {
    if (!graphql_1.isWrappingType(oldType) && !graphql_1.isWrappingType(newType)) {
        return oldType.toString() === newType.toString();
    }
    if (graphql_1.isNonNullType(newType)) {
        var ofType = graphql_1.isNonNullType(oldType) ? oldType.ofType : oldType;
        return safeChangeForField(ofType, newType.ofType);
    }
    if (graphql_1.isListType(oldType)) {
        return ((graphql_1.isListType(newType) &&
            safeChangeForField(oldType.ofType, newType.ofType)) ||
            (graphql_1.isNonNullType(newType) && safeChangeForField(oldType, newType.ofType)));
    }
    return false;
}
exports.safeChangeForField = safeChangeForField;
function safeChangeForInputValue(oldType, newType) {
    if (!graphql_1.isWrappingType(oldType) && !graphql_1.isWrappingType(newType)) {
        return oldType.toString() === newType.toString();
    }
    if (graphql_1.isListType(oldType) && graphql_1.isListType(newType)) {
        return safeChangeForInputValue(oldType.ofType, newType.ofType);
    }
    if (graphql_1.isNonNullType(oldType)) {
        var ofType = graphql_1.isNonNullType(newType) ? newType : newType;
        return safeChangeForInputValue(oldType.ofType, ofType);
    }
    return false;
}
exports.safeChangeForInputValue = safeChangeForInputValue;
function getKind(type) {
    var node = type.astNode;
    return (node && node.kind) || '';
}
exports.getKind = getKind;
function getTypePrefix(type) {
    var _a;
    var kind = getKind(type);
    var kindsMap = (_a = {},
        _a[graphql_1.Kind.SCALAR_TYPE_DEFINITION] = 'scalar',
        _a[graphql_1.Kind.OBJECT_TYPE_DEFINITION] = 'type',
        _a[graphql_1.Kind.INTERFACE_TYPE_DEFINITION] = 'interface',
        _a[graphql_1.Kind.UNION_TYPE_DEFINITION] = 'union',
        _a[graphql_1.Kind.ENUM_TYPE_DEFINITION] = 'enum',
        _a[graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION] = 'input',
        _a);
    return kindsMap[kind];
}
exports.getTypePrefix = getTypePrefix;
function isPrimitive(type) {
    return (['String', 'Int', 'Float', 'Boolean', 'ID'].indexOf(typeof type === 'string' ? type : type.name) !== -1);
}
exports.isPrimitive = isPrimitive;
function isForIntrospection(type) {
    return ([
        '__Schema',
        '__Type',
        '__TypeKind',
        '__Field',
        '__InputValue',
        '__EnumValue',
        '__Directive',
        '__DirectiveLocation',
    ].indexOf(typeof type === 'string' ? type : type.name) !== -1);
}
exports.isForIntrospection = isForIntrospection;
function findDeprecatedUsages(schema, ast) {
    var errors = [];
    var typeInfo = new graphql_1.TypeInfo(schema);
    graphql_1.visit(ast, graphql_1.visitWithTypeInfo(typeInfo, {
        Field: function (node) {
            var fieldDef = typeInfo.getFieldDef();
            if (fieldDef && fieldDef.isDeprecated) {
                var parentType = typeInfo.getParentType();
                if (parentType) {
                    var reason = fieldDef.deprecationReason;
                    errors.push(new graphql_1.GraphQLError("The field '" + parentType.name + "." + fieldDef.name + "' is deprecated." + (reason ? ' ' + reason : ''), [node]));
                }
            }
        },
        EnumValue: function (node) {
            var enumVal = typeInfo.getEnumValue();
            if (enumVal && enumVal.isDeprecated) {
                var type = graphql_1.getNamedType(typeInfo.getInputType());
                if (type) {
                    var reason = enumVal.deprecationReason;
                    errors.push(new graphql_1.GraphQLError("The enum value '" + type.name + "." + enumVal.name + "' is deprecated." + (reason ? ' ' + reason : ''), [node]));
                }
            }
        },
    }));
    return errors;
}
exports.findDeprecatedUsages = findDeprecatedUsages;
function removeFieldIfDirectives(node, directiveNames) {
    if (node.directives) {
        if (node.directives.some(function (d) { return directiveNames.indexOf(d.name.value) !== -1; })) {
            return null;
        }
    }
    return node;
}
exports.removeFieldIfDirectives = removeFieldIfDirectives;
//# sourceMappingURL=graphql.js.map