"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var graphql_2 = require("../utils/graphql");
var string_1 = require("../utils/string");
function similar(schema, typeName, threshold) {
    if (threshold === void 0) { threshold = 0.4; }
    var typeMap = schema.getTypeMap();
    var targets = Object.keys(schema.getTypeMap())
        .filter(function (name) { return !graphql_2.isPrimitive(name) && !graphql_2.isForIntrospection(name); })
        .map(function (name) { return ({
        typeId: name,
        value: stripType(typeMap[name]),
    }); });
    var results = {};
    if (typeof typeName !== 'undefined' &&
        !targets.some(function (t) { return t.typeId === typeName; })) {
        throw new Error("Type '" + typeName + "' doesn't exist");
    }
    (typeName ? [{ typeId: typeName, value: '' }] : targets).forEach(function (source) {
        var sourceType = schema.getType(source.typeId);
        var matchWith = targets.filter(function (target) {
            return schema.getType(target.typeId).astNode.kind ===
                sourceType.astNode.kind && target.typeId !== source.typeId;
        });
        if (matchWith.length > 0) {
            var found = similarTo(sourceType, matchWith, threshold);
            if (found) {
                results[source.typeId] = found;
            }
        }
    });
    return results;
}
exports.similar = similar;
function similarTo(type, targets, threshold) {
    var types = targets.filter(function (target) { return target.typeId !== type.name; });
    var result = string_1.findBestMatch(stripType(type), types);
    if (result.bestMatch.rating < threshold) {
        return;
    }
    return {
        bestMatch: result.bestMatch,
        ratings: result.ratings
            .filter(function (r) { return r.rating >= threshold && r.target !== result.bestMatch.target; })
            .sort(function (a, b) { return a.rating - b.rating; })
            .reverse(),
    };
}
function stripType(type) {
    return graphql_1.printType(type)
        .trim()
        .replace(/^[a-z]+ [^\{]+\{/g, '')
        .replace(/\}$/g, '')
        .trim()
        .split('\n')
        .map(function (s) { return s.trim(); })
        .sort(function (a, b) { return a.localeCompare(b); })
        .join(' ');
}
//# sourceMappingURL=index.js.map