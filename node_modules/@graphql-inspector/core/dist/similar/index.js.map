{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/similar/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {printType, GraphQLNamedType, GraphQLSchema} from 'graphql';\n\nimport {isPrimitive, isForIntrospection} from '../utils/graphql';\nimport {findBestMatch, BestMatch, Target, Rating} from '../utils/string';\n\nexport interface SimilarMap {\n  [name: string]: BestMatch;\n}\n\nexport function similar(\n  schema: GraphQLSchema,\n  typeName: string | undefined,\n  threshold: number = 0.4,\n): SimilarMap {\n  const typeMap = schema.getTypeMap();\n  const targets: Target[] = Object.keys(schema.getTypeMap())\n    .filter(name => !isPrimitive(name) && !isForIntrospection(name))\n    .map(name => ({\n      typeId: name,\n      value: stripType(typeMap[name]),\n    }));\n  const results: SimilarMap = {};\n\n  if (\n    typeof typeName !== 'undefined' &&\n    !targets.some(t => t.typeId === typeName)\n  ) {\n    throw new Error(`Type '${typeName}' doesn't exist`);\n  }\n\n  (typeName ? [{typeId: typeName, value: ''}] : targets).forEach(source => {\n    const sourceType = schema.getType(source.typeId) as GraphQLNamedType;\n    const matchWith = targets.filter(\n      target =>\n        (schema.getType(target.typeId) as any).astNode.kind ===\n          (sourceType.astNode as any).kind && target.typeId !== source.typeId,\n    );\n\n    if (matchWith.length > 0) {\n      const found = similarTo(sourceType, matchWith, threshold);\n\n      if (found) {\n        results[source.typeId] = found;\n      }\n    }\n  });\n\n  return results;\n}\n\nfunction similarTo(\n  type: GraphQLNamedType,\n  targets: Target[],\n  threshold: number,\n): BestMatch | undefined {\n  const types = targets.filter(target => target.typeId !== type.name);\n  const result = findBestMatch(stripType(type), types);\n\n  if (result.bestMatch.rating < threshold) {\n    return;\n  }\n\n  return {\n    bestMatch: result.bestMatch,\n    ratings: result.ratings\n      .filter(\n        r => r.rating >= threshold && r.target !== result.bestMatch.target,\n      )\n      .sort((a: Rating, b: Rating) => a.rating - b.rating)\n      .reverse(),\n  };\n}\n\nfunction stripType(type: GraphQLNamedType): string {\n  return printType(type)\n    .trim()\n    .replace(/^[a-z]+ [^\\{]+\\{/g, '')\n    .replace(/\\}$/g, '')\n    .trim()\n    .split('\\n')\n    .map(s => s.trim())\n    .sort((a, b) => a.localeCompare(b))\n    .join(' ');\n}\n"]}